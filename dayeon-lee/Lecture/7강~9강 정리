## 큐

- 한쪽 끝에서 원소를 넣고, 반대쪽 끝에서 원소를 뺄 수 있는 자료구조 (FIFO / First in First out)
- 원소가 추가되는 쪽 → rear(뒤쪽) , 원소가 제거되는 쪽 → front(앞쪽)
- 시간 복잡도
    1. 원소의 추가 → O(1)
    2. 원소의 제거 → O(1)
    3. 제일 앞/뒤 원소의 확인 → O(1)
    4. 제일 앞/뒤 가 아닌 나머지 원소들의 확인/변경이 원칙적으로 불가능 → 배열로 queue를 만드는 경우는 구현 가능
- 구현
    - 원소를 담을 큰 배열 1개 + 뒤쪽을 가리킬 변수 2개 (head, tail)

## 덱

- 양쪽 끝에서 삽입, 삭제 가능
- 시간 복잡도
    1. 원소의 추가 → O(1)
    2. 원소의 제거 → O(1)
    3. 제일 앞/뒤 원소의 확인 → O(1)
    4. 제일 앞/뒤 가 아닌 나머지 원소들의 확인/변경이 원칙적으로 불가능 → 인덱스로는 접근 가능
- 구현
    - 원소를 담을 큰 배열 1개 + 뒤쪽을 가리킬 변수 2개 (head, tail)
    - head: 가장 앞에 있는 원소의 인덱스 , 초기값 MX
    - tail: 가장 뒤에 있는 원소의 인덱스 + 1, 초기값 MX
    - 초기값 MX 인 이유? → 양쪽 확장을 위해 배열의 중간으로 초기값을 둠 , 배열의 크기 = 2*MX + 1

## 스택의 활용

- 수식의 괄호 쌍 문제
    - 여는 괄호를 읽을 때 마다 → 닫는 괄호를 읽을 때 가장 최근에 들어온, 즉 가장 끝에 있는 여는 괄호와 짝을 이루게 해주고 pop을 하면 올바른 괄호 쌍인지 확인할 수 있음
- 문제 해결 방법
    1. 여는 괄호가 나오면 스택에 추가
    2. 닫는 괄호가 나왔을 경우
        1. 스택이 비어있음 → 올바르지 않은 괄호 쌍
        2. 스택의 top이 짝이 맞지 않는 괄호인 경우 → 올바르지 않는 괄호 쌍
        3. 스택의 top이 짝이 맞는 괄호인 경우 → pop
    3. 모든 과정이 끝난 후 스택에 괄호가 남아있으면 올바르지 않는 괄호 쌍, 남아있다면 올바른 괄호 쌍
