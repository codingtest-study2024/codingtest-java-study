#바킹독의 실전 알고리즘 강의

#0521
#0x00강 – 오리엔테이션

#0x01강 – 기초 코드 작성 요령1
시간복잡도(Time Complexity)
: 입력의 크기와 문제를 해결하는데 걸리는 시간의 상관관계

빅오표기법
: 주어진 식을 값이 가장 큰 대표항만 남겨서 나타내는 방법

공간복잡도(Space Complexity)
: 입력의 크기와 문제를 해결하는데 필요한 공간의 상관관계

#0x02강 – 기초 코드 작성 요령2
1. 표준 입출력
(c++ 기준 강의) endl을 사용하지 말자.

2. 코드 작성 팁
코딩테스트와 개발은 다르다.

#0528
#0x03강 - 배열
insert 구현
for (int I=len; i>idx; I++){	arr[i]=arr[i-1];
}
arr[idx] = num;
len++;

//문제2
주어진 길이 N의 int배열 arr에서 합이 100인 서로 다른 위치의 두 원소가 존재하면 1을, 존재하지 않으면 0을 반환하는 함수 func2(int arr[], int N)을 작성하라. arr의 각 수는 0 이상 100이하이고 N은 1000이하이다.

int func2(int arr[], int N){
  int occur[101] = {};
  for(int i = 0; i < N; i++){
    if(occur[100-arr[i]] == 1)
      return 1;
    occur[arr[i]] = 1;
  }
  return 0;
}

#0x04강 – 연결리스트
연결 리스트의 종류
● 단일 연결 리스트
각 원소가 자신의 다음 원소의 주소를 갖고 있는 연결 리스트

● 이중 연결 리스트
이중 연결 리스트에서는 각 원소가 자신의 이전 원소와 다음 원소의 주소를 모두 갖고 있다. 단일 연결 리스트에서는 이전 주소를 알 수 없었지만, 이중 연결 리스트는 자신의 이전, 다음 주소를 알 수 있다.

● 원형 연결 리스트
마지막 원소가 처음 원소와 연결되어 있다. 각 원소가 이전과 다음 원소의 주소를 모두 보유하고 있어도 무관하다.

임의의 위치에 있는 원소를 확인/변경 = O(N)
임의의 위치에 원소를 추가/임의 위치의 원소 제거 = O(1)

#0x05강 – 스택(Stack)
스택은 한쪽 끝에서만 원소를 넣거나 뺄 수 있다. LIFO 후입 선출 자료구조이다.
시간 복잡도는 다음과 같다.
1. 원소의 추가 O(1)
2. 원소의 제거 O(1)
3. 제일 상단의 원소 확인 O(1)
4. 제일 상단이 아닌 나머지 원소들의 확인/변경은 원칙적으로 불가능

#0x06강 – 큐(Queue)
1. 큐는 FIFO로 먼저 들어간 자료가 먼저 나오는 구조.
2. 성질
* 원소의 추가, O(1)
* 원소의 제거, O(1)
* 제일 앞/뒤 원소 확인, O(1)
* 제일 앞/뒤가 아닌 나머지 원소들의 확인/변경이 원칙적으로 불가능

#0x07강 – 덱(Deque)
1. 양쪽 끝에서 삽입과 삭제가 전부 가능한 구조. Double Ended Queue라는 뜻
2. 성질
* 원소 추가, O(1)
* 원소 제거, O(1)
* 원소의 제일 앞/뒤 확인, O(1)
* 제일 앞/뒤가 아닌 나머지 원소들의 확인/변경은 원칙적으로 불가함
허나 STL Deque에서는 인덱스로 원소에 접근할 수 있음

3. 구현
자바에서는 Deque을 구현할 때 LinkedList<E> 을 활용하는 것이 더 좋다고 한다.

#0x08강 – 스택의 활용(수식의 괄호 쌍)
주어진 괄호 문자열이 올바른지 판단하는 문제.
문자열을 앞에서부터 읽어나갈 때, 닫는 괄호는 남아있는 괄호 중 가장 최근에 들어온 여는 괄호와 짝을 지어 없애버리는 것으로 접근. 

문제 해결방법
- 여는 괄호를 스택에 추가
- 닫는 괄호일 경우
* 스택이 비어있으면 올바르지 않는 괄호 ( return False )
* 스택의 top과 짝이 맞지 않을 경우 올바르지 않는 괄호 ( return False )
* 스택의 top이 짝과 맞는 괄호일 경우 pop
- 모든 과정을 끝낸 후 스택에 괄호가 남아있으면 올바르지 않고, 남아있지 않으면 올바른 괄호임
